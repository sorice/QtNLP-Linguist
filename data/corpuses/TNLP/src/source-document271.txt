Java (lenguaje de programación)

Java es un lenguaje de programación de propósito general, concurrente, orientado a objetos y basado en clases que fue diseñado específicamente para tener tan pocas dependencias de implementación como fuera posible. Su intención es permitir que los desarrolladores de aplicaciones escriban el programa una vez y lo ejecuten en cualquier dispositivo (conocido en inglés como WORA, o "write once, run anywhere"), lo que quiere decir que el código que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra. Java es, a partir de 2012, uno de los lenguajes de programación más populares en uso, particularmente para aplicaciones de cliente-servidor de web, con unos 10 millones de usuarios reportados.2 3

El lenguaje de programación Java fue originalmente desarrollado por James Gosling de Sun Microsystems (la cual fue adquirida por la compañía Oracle) y publicado en 1995 como un componente fundamental de la plataforma Java de Sun Microsystems. Su sintaxis deriva en gran medida de C y C++, pero tiene menos utilidades de bajo nivel que cualquiera de ellos. Las aplicaciones de Java son generalmente compiladas a bytecode (clase Java) que puede ejecutarse en cualquier máquina virtual Java (JVM) sin importar la arquitectura de la computadora subyacente.

La compañía Sun desarrolló la implementación de referencia original para los compiladores de Java, máquinas virtuales, y librerías de clases en 1991 y las publicó por primera vez en 1995. A partir de mayo de 2007, en cumplimiento con las especificaciones del Proceso de la Comunidad Java, Sun volvió a licenciar la mayoría de sus tecnologías de Java bajo la Licencia Pública General de GNU. Otros también han desarrollado implementaciones alternas a estas tecnologías de Sun, tales como el Compilador de Java de GNU y el GNU Classpath.

Historia

Java se creó como una herramienta de programación para ser usada en un proyecto de set-top-box en una pequeña operación denominada the Green Project en Sun Microsystems en el año 1991. El equipo (Green Team), compuesto por trece personas y dirigido por James Gosling, trabajó durante 18 meses en Sand Hill Road en Menlo Park en su desarrollo.

El lenguaje se denominó inicialmente Oak (por un roble que había fuera de la oficina de Gosling), luego pasó a denominarse Green tras descubrir que Oak era ya una marca comercial registrada para adaptadores de tarjetas gráficas y finalmente se renombró a Java.

Es frecuentada por algunos de los miembros del equipo. Pero no está claro si es un acrónimo o no, aunque algunas fuentes señalan que podría tratarse de las iniciales de sus creadores: James Gosling, Arthur Van Hoff, y Andy Bechtolsheim. Otros abogan por el siguiente acrónimo, Just Another Vague Acronym ("sólo otro acrónimo ambiguo más"). La hipótesis que más fuerza tiene es la de que Java debe su nombre a un tipo de café disponible en la cafetería cercana, de ahí que el icono de java sea una taza de café caliente. Un pequeño signo que da fuerza a esta teoría es que los 4 primeros bytes (el número mágico) de los archivos.class que genera el compilador, son en hexadecimal, 0xCAFEBABE. A pesar de todas estas teorías, el nombre fue sacado al parecer de una lista aleatoria de palabras.4

Los objetivos de Gosling eran implementar una máquina virtual y un lenguaje con una estructura y sintaxis similar a C++. Entre junio y julio de 1994, tras una sesión maratoniana de tres días entre John Gaga, James Gosling, Patrick Naughton, Wayne Rosing y Eric Schmidt, el equipo reorientó la plataforma hacia la Web. Sintieron que la llegada del navegador web Mosaic, propiciaría que Internet se convirtiese en un medio interactivo, como el que pensaban era la televisión por cable. Naughton creó entonces un prototipo de navegador, WebRunner, que más tarde sería conocido como HotJava.

En 1994, se les hizo una demostración de HotJava y la plataforma Java a los ejecutivos de Sun. Java 1.0a pudo descargarse por primera vez en 1994, pero hubo que esperar al 23 de mayo de 1995, durante las conferencias de SunWorld, a que vieran la luz pública Java y HotJava, el navegador Web. El acontecimiento fue anunciado por John Gage, el Director Científico de Sun Microsystems. El acto estuvo acompañado por una pequeña sorpresa adicional, el anuncio por parte de Marc Andreessen, Vicepresidente Ejecutivo de Netscape, de que Java sería soportado en sus navegadores. El 9 de enero del año siguiente, 1996, Sun fundó el grupo empresarial JavaSoft para que se encargase del desarrollo tecnológico. [1] Dos semanas más tarde la primera versión de Java fue publicada.

La promesa inicial de Gosling era Write Once, Run Anywhere (Escríbelo una vez, ejecútalo en cualquier lugar), proporcionando un lenguaje independiente de la plataforma y un entorno de ejecución (la JVM) ligero y gratuito para las plataformas más populares de forma que los binarios (bytecode) de las aplicaciones Java pudiesen ejecutarse en cualquier plataforma.

El entorno de ejecución era relativamente seguro y los principales navegadores web pronto incorporaron la posibilidad de ejecutar applets Java incrustadas en las páginas web.

Java ha experimentado numerosos cambios desde la versión primigenia, JDK 1.0, así como un enorme incremento en el número de clases y paquetes que componen la biblioteca estándar.5

Desde J2SE 1.4, la evolución del lenguaje ha sido regulada por el JCP (Java Community Process), que usa Java Specification Requests (JSRs) para proponer y especificar cambios en la plataforma Java. El lenguaje en sí mismo está especificado en la Java Language Specification (JLS), o Especificación del Lenguaje Java. Los cambios en los JLS son gestionados en JSR 901.

- JDK 1.0 (23 de enero de 1996) — Primer lanzamiento: comunicado de prensa
- JDK 1.1 (19 de febrero de 1997) — Principales adiciones incluidas: comunicado de prensa
	- una reestructuración intensiva del modelo de eventos AWT (Abstract Windowing Toolkit)
	- clases internas (inner classes)
	- JavaBeans
	- JDBC (Java Database Connectivity), para la integración de bases de datos
	- RMI (Remote Method Invocation)
- J2SE 1.2 (8 de diciembre de 1998) — Nombre clave Playground. Esta y las siguientes versiones fueron recogidas bajo la denominación Java 2 y el nombre "J2SE" (Java 2 Platform, Standard Edition), reemplazó a JDK para distinguir la plataforma base de J2EE (Java 2 Platform, Enterprise Edition) y J2ME (Java 2 Platform, Micro Edition). Otras mejoras añadidas incluían: comunicado de prensa
	- la palabra reservada (keyword) strictfp
	- reflexión en la programación
	- la API gráfica ( Swing) fue integrada en las clases básicas
	- la máquina virtual (JVM) de Sun fue equipada con un compilador JIT (Just in Time) por primera vez
	- Java Plug-in
	- Java IDL, una implementación de IDL (Lenguaje de Descripción de Interfaz) para la interoperabilidad con CORBA
	- Colecciones (Collections)
- J2SE 1.3 (8 de mayo de 2000) — Nombre clave Kestrel. Los cambios más notables fueron:comunicado de prensa lista completa de cambios
	- la inclusión de la máquina virtual de HotSpot JVM (la JVM de HotSpot fue lanzada inicialmente en abril de 1999, para la JVM de J2SE 1.2)
	- RMI fue cambiado para que se basara en CORBA
	- JavaSound
	- se incluyó el Java Naming and Directory Interface (JNDI) en el paquete de bibliotecas principales (anteriormente disponible como una extensión)
	- Java Platform Debugger Architecture (JPDA)
- J2SE 1.4 (6 de febrero de 2002) — Nombre Clave Merlin. Este fue el primer lanzamiento de la plataforma Java desarrollado bajo el Proceso de la Comunidad Java como JSR 59. Los cambios más notables fueron: comunicado de prensalista completa de cambios
	- Palabra reservada assert (Especificado en JSR 41.)
	- Expresiones regulares modeladas al estilo de las expresiones regulares Perl
	- Encadenación de excepciones Permite a una excepción encapsular la excepción de bajo nivel original.
	- non-blocking NIO (New Input/Output) (Especificado en JSR 51.)
	- Logging API (Specified in JSR 47.)
	- API I/O para la lectura y escritura de imágenes en formatos como JPEG o PNG
	- Parser XML integrado y procesador XSLT (JAXP) (Especificado en JSR 5 y JSR 63.)
	- Seguridad integrada y extensiones criptográficas (JCE, JSSE, JAAS)
	- Java Web Start incluido (El primer lanzamiento ocurrió en marzo de 2001 para J2SE 1.3) (Especificado en JSR 56.)
- J2SE 5.0 (30 de septiembre de 2004) — Nombre clave: Tiger. (Originalmente numerado 1.5, esta notación aún es usada internamente.[2]) Desarrollado bajo JSR 176, Tiger añadió un número significativo de nuevas características comunicado de prensa
	- Plantillas (genéricos) — provee conversión de tipos (type safety) en tiempo de compilación para colecciones y elimina la necesidad de la mayoría de conversión de tipos (type casting). (Especificado por JSR 14.)
	- Metadatos — también llamados anotaciones, permite a estructuras del lenguaje como las clases o los métodos, ser etiquetados con datos adicionales, que puedan ser procesados posteriormente por utilidades de proceso de metadatos. (Especificado por JSR 175.)
	- Autoboxing/unboxing — Conversiones automáticas entre tipos primitivos (Como los int) y clases de envoltura primitivas (Como Integer). (Especificado por JSR 201.)
	- Enumeraciones — la palabra reservada enum crea una typesafe, lista ordenada de valores (como Dia.LUNES, Dia.MARTES, etc.). Anteriormente, esto solo podía ser llevado a cabo por constantes enteras o clases construidas manualmente (enum pattern). (Especificado por JSR 201.)
	- Varargs (número de argumentos variable) — El último parámetro de un método puede ser declarado con el nombre del tipo seguido por tres puntos (e.g. void drawtext(String... lines)). En la llamada al método, puede usarse cualquier número de parámetros de ese tipo, que serán almacenados en un array para pasarlos al método.
	- Bucle for mejorado — La sintaxis para el bucle for se ha extendido con una sintaxis especial para iterar sobre cada miembro de un array o sobre cualquier clase que implemente Iterable, como la clase estándar Collection, de la siguiente forma:

 void displayWidgets (Iterable<Widget> widgets) {
     for (Widget w : widgets) {
         w.display();
     }
 }

Este ejemplo itera sobre el objeto Iterable widgets, asignando, en orden, cada uno de los elementos a la variable w, y llamando al método display() de cada uno de ellos. (Especificado por JSR 201.)

- Java SE 6 (11 de diciembre de 2006) — Nombre clave Mustang. Estuvo en desarrollo bajo la JSR 270. En esta versión, Sun cambió el nombre "J2SE" por Java SE y eliminó el ".0" del número de versión.[3]. Está disponible en http://java.sun.com/javase/6/. Los cambios más importantes introducidos en esta versión son:
	- Incluye un nuevo marco de trabajo y APIs que hacen posible la combinación de Java con lenguajes dinámicos como PHP, Python, Ruby y JavaScript.
	- Incluye el motor Rhino, de Mozilla, una implementación de Javascript en Java.
	- Incluye un cliente completo de Servicios Web y soporta las últimas especificaciones para Servicios Web, como JAX-WS 2.0, JAXB 2.0, STAX y JAXP.
	- Mejoras en la interfaz gráfica y en el rendimiento.
- Java SE 7 — Nombre clave Dolphin. En el año 2006 aún se encontraba en las primeras etapas de planificación. Su lanzamiento fue en julio de 2011.
	- Soporte para XML dentro del propio lenguaje.
	- Un nuevo concepto de superpaquete.
	- Soporte para closures.
	- Introducción de anotaciones estándar para detectar fallos en el software.
- No oficiales:
	- NIO2.
	- Java Module System.
	- Java Kernel.
	- Nueva API para el manejo de Días y Fechas, la cual reemplazara las antiguas clases Date y Calendar.
	- Posibilidad de operar con clases BigDecimal usando operandos.
- Java SE 8 — lanzada en marzo de 2014. Cabe destacar:
	- Incorpora de forma completa la librería JavaFX.
	- Diferentes mejoras en seguridad.
	- Diferentes mejoras en concurrencia.
	- Añade funcionalidad para programación funcional mediante expresiones Lambda.
	- Mejora la integración de JavaScript.
	- Nuevas API para manejo de fechas y tiempo (date - time).

En el 2005 se calcula en 4,5 millones el número de desarrolladores y 2.500 millones de dispositivos habilitados con tecnología Java.

Filosofía

El lenguaje Java se creó con cinco objetivos principales:
1. Debería usar el paradigma de la programación orientada a objetos.
2. Debería permitir la ejecución de un mismo programa en múltiples sistemas operativos.
3. Debería incluir por defecto soporte para trabajo en red.
4. Debería diseñarse para ejecutar código en sistemas remotos de forma segura.
5. Debería ser fácil de usar y tomar lo mejor de otros lenguajes orientados a objetos, como C++.

Para conseguir la ejecución de código remoto y el soporte de red, los programadores de Java a veces recurren a extensiones como CORBA (Common Object Request Broker Architecture), Internet Communications Engine o OSGi respectivamente.

Orientado a objetos

La primera característica, orientado a objetos (“OO”), se refiere a un método de programación y al diseño del lenguaje. Aunque hay muchas interpretaciones para OO, una primera idea es diseñar el software de forma que los distintos tipos de datos que usen estén unidos a sus operaciones. Así, los datos y el código (funciones o métodos) se combinan en entidades llamadas objetos. Un objeto puede verse como un paquete que contiene el “comportamiento” (el código) y el “estado” (datos). El principio es separar aquello que cambia de las cosas que permanecen inalterables. Frecuentemente, cambiar una estructura de datos implica un cambio en el código que opera sobre los mismos, o viceversa. Esta separación en objetos coherentes e independientes ofrece una base más estable para el diseño de un sistema software. El objetivo es hacer que grandes proyectos sean fáciles de gestionar y manejar, mejorando como consecuencia su calidad y reduciendo el número de proyectos fallidos. Otra de las grandes promesas de la programación orientada a objetos es la creación de entidades más genéricas (objetos) que permitan la reutilización del software entre proyectos, una de las premisas fundamentales de la Ingeniería del Software. Un objeto genérico “cliente”, por ejemplo, debería en teoría tener el mismo conjunto de comportamiento en diferentes proyectos, sobre todo cuando estos coinciden en cierta medida, algo que suele suceder en las grandes organizaciones. En este sentido, los objetos podrían verse como piezas reutilizables que pueden emplearse en múltiples proyectos distintos, posibilitando así a la industria del software a construir proyectos de envergadura empleando componentes ya existentes y de comprobada calidad; conduciendo esto finalmente a una reducción drástica del tiempo de desarrollo. Podemos usar como ejemplo de objeto el aluminio. Una vez definidos datos (peso, maleabilidad, etc.), y su “comportamiento” (soldar dos piezas, etc.), el objeto “aluminio” puede ser reutilizado en el campo de la construcción, del automóvil, de la aviación, etc.

La reutilización del software ha experimentado resultados dispares, encontrando dos dificultades principales: el diseño de objetos realmente genéricos es pobremente comprendido, y falta una metodología para la amplia comunicación de oportunidades de reutilización. Algunas comunidades de “código abierto” (open source) quieren ayudar en este problema dando medios a los desarrolladores para diseminar la información sobre el uso y versatilidad de objetos reutilizables y bibliotecas de objetos.

Independencia de la plataforma

La segunda característica, la independencia de la plataforma, significa que programas escritos en el lenguaje Java pueden ejecutarse igualmente en cualquier tipo de hardware. Este es el significado de ser capaz de escribir un programa una vez y que pueda ejecutarse en cualquier dispositivo, tal como reza el axioma de Java, "write once, run anywhere".

Para ello, se compila el código fuente escrito en lenguaje Java, para generar un código conocido como “bytecode” (específicamente Java bytecode)—instrucciones máquina simplificadas específicas de la plataforma Java. Esta pieza está “a medio camino” entre el código fuente y el código máquina que entiende el dispositivo destino. El bytecode es ejecutado entonces en la máquina virtual (JVM), un programa escrito en código nativo de la plataforma destino (que es el que entiende su hardware), que interpreta y ejecuta el código. Además, se suministran bibliotecas adicionales para acceder a las características de cada dispositivo (como los gráficos, ejecución mediante hebras o threads, la interfaz de red) de forma unificada. Se debe tener presente que, aunque hay una etapa explícita de compilación, el bytecode generado es interpretado o convertido a instrucciones máquina del código nativo por el compilador JIT (Just In Time).

Hay implementaciones del compilador de Java que convierten el código fuente directamente en código objeto nativo, como GCJ. Esto elimina la etapa intermedia donde se genera el bytecode, pero la salida de este tipo de compiladores sólo puede ejecutarse en un tipo de arquitectura.

La licencia sobre Java de Sun insiste que todas las implementaciones sean “compatibles”. Esto dio lugar a una disputa legal entre Microsoft y Sun, cuando éste último alegó que la implementación de Microsoft no daba soporte a las interfaces RMI y JNI además de haber añadido características ‘’dependientes’’ de su plataforma. Sun demandó a Microsoft y ganó por daños y perjuicios (unos 20 millones de dólares) así como una orden judicial forzando la acatación de la licencia de Sun. Como respuesta, Microsoft no ofrece Java con su versión de sistema operativo, y en recientes versiones de Windows, su navegador Internet Explorer no admite la ejecución de applets sin un conector (o plugin) aparte. Sin embargo, Sun y otras fuentes ofrecen versiones gratuitas para distintas versiones de Windows.

Las primeras implementaciones del lenguaje usaban una máquina virtual interpretada para conseguir la portabilidad. Sin embargo, el resultado eran programas que se ejecutaban comparativamente más lentos que aquellos escritos en C o C++. Esto hizo que Java se ganase una reputación de lento en rendimiento. Las implementaciones recientes de la JVM dan lugar a programas que se ejecutan considerablemente más rápido que las versiones antiguas, empleando diversas técnicas, aunque sigue siendo mucho más lento que otros lenguajes.

La primera de estas técnicas es simplemente compilar directamente en código nativo como hacen los compiladores tradicionales, eliminando la etapa del bytecode. Esto da lugar a un gran rendimiento en la ejecución, pero tapa el camino a la portabilidad. Otra técnica, conocida como compilación JIT (Just In Time, o "compilación al vuelo"), convierte el bytecode a código nativo cuando se ejecuta la aplicación. Otras máquinas virtuales más sofisticadas usan una "recompilación dinámica" en la que la VM es capaz de analizar el comportamiento del programa en ejecución y recompila y optimiza las partes críticas. La recompilación dinámica puede lograr mayor grado de optimización que la compilación tradicional (o estática), ya que puede basar su trabajo en el conocimiento que de primera mano tiene sobre el entorno de ejecución y el conjunto de clases cargadas en memoria. La compilación JIT y la recompilación dinámica permiten a los programas Java aprovechar la velocidad de ejecución del código nativo sin por ello perder la ventaja de la portabilidad en ambos.

La portabilidad es técnicamente difícil de lograr, y el éxito de Java en ese campo ha sido dispar. Aunque es de hecho posible escribir programas para la plataforma Java que actúen de forma correcta en múltiples plataformas de distinta arquitectura, el gran número de estas con pequeños errores o inconsistencias llevan a que a veces se parodie el eslogan de Sun, "Write once, run anywhere" como "Write once, debug everywhere" (o “Escríbelo una vez, ejecútalo en cualquier parte” por “Escríbelo una vez, depúralo en todas partes”).

El concepto de independencia de la plataforma de Java cuenta, sin embargo, con un gran éxito en las aplicaciones en el entorno del servidor, como los Servicios Web, los Servlets, los Java Beans, así como en sistemas empotrados basados en OSGi, usando entornos Java empotrados.

El recolector de basura

En Java el problema fugas de memoria se evita en gran medida gracias a la recolección de basura (o automatic garbage collector). El programador determina cuándo se crean los objetos y el entorno en tiempo de ejecución de Java (Java runtime) es el responsable de gestionar el ciclo de vida de los objetos. El programa, u otros objetos pueden tener localizado un objeto mediante una referencia a éste. Cuando no quedan referencias a un objeto, el recolector de basura de Java borra el objeto, liberando así la memoria que ocupaba previniendo posibles fugas (ejemplo: un objeto creado y únicamente usado dentro de un método sólo tiene entidad dentro de éste; al salir del método el objeto es eliminado). Aun así, es posible que se produzcan fugas de memoria si el código almacena referencias a objetos que ya no son necesarios—es decir, pueden aún ocurrir, pero en un nivel conceptual superior. En definitiva, el recolector de basura de Java permite una fácil creación y eliminación de objetos y mayor seguridad.

Sintaxis

La sintaxis de Java se deriva en gran medida de C++. Pero a diferencia de éste, que combina la sintaxis para programación genérica, estructurada y orientada a objetos, Java fue construido desde el principio para ser completamente orientado a objetos. Todo en Java es un objeto (salvo algunas excepciones), y todo en Java reside en alguna clase (recordemos que una clase es un molde a partir del cual pueden crearse varios objetos).

Aplicaciones autónomas

Este ejemplo necesita una pequeña explicación.
- Todo en Java está dentro de una clase, incluyendo programas autónomos.
- El código fuente se guarda en archivos con el mismo nombre que la clase que contienen y con extensión “.java”. Una clase (class) declarada pública (public) debe seguir este convenio. En el ejemplo anterior, la clase es Hola, por lo que el código fuente debe guardarse en el fichero “Hola.java”
- El compilador genera un archivo de clase (con extensión “.class”) por cada una de las clases definidas en el archivo fuente. Una clase anónima se trata como si su nombre fuera la concatenación del nombre de la clase que la encierra, el símbolo “$”, y un número entero.
- Los programas que se ejecutan de forma independiente y autónoma, deben contener el método ”main()”.
- La palabra reservada ”void” indica que el método main no devuelve nada.
- El método main debe aceptar un array de objetos tipo String. Por acuerdo se referencia como ”args”, aunque puede emplearse cualquier otro identificador.
- La palabra reservada ”static” indica que el método es un método de clase, asociado a la clase en vez de a una instancia de la misma. El método main debe ser estático o ’’de clase’’.
- La palabra reservada public significa que un método puede ser llamado desde otras clases, o que la clase puede ser usada por clases fuera de la jerarquía de la propia clase. Otros tipos de acceso son ”private” o ”protected”.
- La utilidad de impresión (en pantalla por ejemplo) forma parte de la biblioteca estándar de Java: la clase ‘’’System’’’ define un campo público estático llamado ‘’’out’’’. El objeto out es una instancia de ‘’’PrintStream’’’, que ofrece el método ‘’’println (String)’’’ para volcar datos en la pantalla (la salida estándar).
- Las aplicaciones autónomas se ejecutan dando al entorno de ejecución de Java el nombre de la clase cuyo método main debe invocarse. Por ejemplo, una línea de comando (en Unix o Windows) de la forma java –cp . Hola ejecutará el programa del ejemplo (previamente compilado y generado “Hola.class”). El nombre de la clase cuyo método main se llama puede especificarse también en el fichero “MANIFEST” del archivo de empaquetamiento de Java (.jar).

Applets

Las applet Java son programas incrustados en otras aplicaciones, normalmente una página Web que se muestra en un navegador.

// Hello.java
import javax.swing.JApplet;
import java.awt.Graphics;
 
public class Hello extends JApplet {
 
       public void paint(Graphics g) {
        g.drawString("Hola, mundo!", 65, 95);
    }
 
}

 <!-- Hola.html -->
<html>
  <head>
    <title>Applet Hola Caracola</title>
  </head>
  <body>
    <applet code="Hola.class" width="200" height="200">
    </applet>
  </body>
</html>

Actualmente HTML 5 ha eliminado el uso de la etiqueta <applet>. Pero todavía existe la forma de usarlo en HTML5. (Texto en inglés) Java Applets in HTML5.

La sentencia import indica al compilador de Java que incluya las clases java.applet. Applet y java.awt. Graphics, para poder referenciarlas por sus nombres, sin tener que anteponer la ruta completa cada vez que se quieran usar en el código fuente.

La clase Hola extiende (extends) a la clase Applet, es decir, es una subclase de ésta. La clase Applet permite a la aplicación mostrar y controlar el estado del applet. La clase Applet es un componente del AWT (Abstract Window Toolkit), que permite al applet mostrar una interfaz gráfica de usuario o GUI (Graphical User Interface), y responder a eventos generados por el usuario.

La clase Hola sobrecarga el método paint (Graphics) heredado de la superclase contenedora (Applet en este caso), para acceder al código encargado de dibujar. El método paint() recibe un objeto Graphics que contiene el contexto gráfico para dibujar el applet. El método paint() llama al método drawString (String, int, int) del objeto [4]

Servlets

Los servlets son componentes de la parte del servidor de Java EE, encargados de generar respuestas a las peticiones recibidas de los clientes.

// Hola.java
import java.io.IOException; 
import javax.servlet.*;
 
public class Hola extends GenericServlet 
{
    public void service(ServletRequest request, ServletResponse response)
        throws ServletException, IOException
    {
        response.setContentType("text/html");
        PrintWriter pw = response.getWriter();
        pw.println("Hola, mundo!");
        pw.close();
    }
}

Las sentencias import indican al compilador de Java la inclusión de todas las clases públicas e interfaces de los paquetes java.io y javax.servlet en la compilación.

La clase Hola extiende (extends), es heredera de la clase GenericServlet. Esta clase proporciona la interfaz para que el servidor le pase las peticiones al servlet y el mecanismo para controlar el ciclo de vida del servlet.

La clase Hola sobrecarga el método service (ServletRequest, ServletResponse), definido por la interfaz servlet para acceder al manejador de la petición de servicio. El método service() recibe un objeto de tipo ServletRequest que contiene la petición del cliente y un objeto de tipo ServletResponse, usado para generar la respuesta que se devuelve al cliente. El método service() puede lanzar (throws) excepciones de tipo ServletException e IOException si ocurre algún tipo de anomalía.

El método setContentType (String) en el objeto respuesta establece el tipo de contenido MIME a "text/html", para indicar al cliente que la respuesta a su petición es una página con formato HTML. El método getWriter() del objeto respuesta devuelve un objeto de tipo PrintWriter, usado como una tubería por la que viajarán los datos al cliente. El método println (String) escribe la cadena "Hola, mundo!" en la respuesta y finalmente se llama al método close() para cerrar la conexión, que hace que los datos escritos en la tubería o stream sean devueltos al cliente.

Aplicaciones con ventanas

Swing es la biblioteca para la interfaz gráfica de usuario avanzada de la plataforma Java SE.

 // Hola.java
 import javax.swing.*;
 
 public class Hola extends JFrame {
     Hola() {
         setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
         add(new JLabel("Hola, mundo!"));
         pack();
     }
 
     public static void main(String[] args) {
         new Hola().setVisible(true);
     }
 }

Las instrucciones import indican al compilador de Java que las clases e interfaces del paquete javax.swing se incluyan en la compilación.

La clase Hola extiende (extends) la clase javax.swing.JFrame, que implementa una ventana con una barra de título y un control para cerrarla.

El constructor Hola() inicializa el marco o frame llamando al método setDefaultCloseOperation (int) heredado de JFrame para establecer las operaciones por defecto cuando el control de cierre en la barra de título es seleccionado al valor WindowConstants.DISPOSE_ON_CLOSE. Esto hace que se liberen los recursos tomados por la ventana cuando es cerrada, y no simplemente ocultada, lo que permite a la máquina virtual y al programa acabar su ejecución. A continuación se crea un objeto de tipo JLabel con el texto "Hola, mundo!", y se añade al marco mediante el método add (Component), heredado de la clase Container. El método pack(), heredado de la clase Window, es invocado para dimensionar la ventana y distribuir su contenido.

El método main() es llamado por la JVM al comienzo del programa. Crea una instancia de la clase Hola y hace la ventana sea mostrada invocando al método setVisible (boolean) de la superclase (clase de la que hereda) con el parámetro a true. Véase que, una vez el marco es dibujado, el programa no termina cuando se sale del método main(), ya que el código del que depende se encuentra en un hilo de ejecución independiente ya lanzado, y que permanecerá activo hasta que todas las ventanas hayan sido destruidas.

Entornos de funcionamiento

El diseño de Java, su robustez, el respaldo de la industria y su fácil portabilidad han hecho de Java uno de los lenguajes con un mayor crecimiento y amplitud de uso en distintos ámbitos de la industria de la informática.

En dispositivos móviles y sistemas empotrados

Desde la creación de la especificación J2ME (Java 2 Platform, Micro Edition), una versión del entorno de ejecución Java reducido y altamente optimizado, especialmente desarrollado para el mercado de dispositivos electrónicos de consumo se ha producido toda una revolución en lo que a la extensión de Java se refiere.

Es posible encontrar microprocesadores diseñados para ejecutar bytecode Java y software Java para tarjetas inteligentes (JavaCard), teléfonos móviles, buscapersonas, set-top-boxes, sintonizadores de TV y otros pequeños electrodomésticos.

El modelo de desarrollo de estas aplicaciones es muy semejante a las applets de los navegadores salvo que en este caso se denominan MIDlets.

Véase Sun Mobile Device Tecnology

En el navegador web

Desde la primera versión de java existe la posibilidad de desarrollar pequeñas aplicaciones (Applets) en Java que luego pueden ser incrustadas en una página HTML para que sean descargadas y ejecutadas por el navegador web. Estas mini-aplicaciones se ejecutan en una JVM que el navegador tiene configurada como extensión (plug-in) en un contexto de seguridad restringido configurable para impedir la ejecución local de código potencialmente malicioso.

El éxito de este tipo de aplicaciones (la visión del equipo de Gosling) no fue realmente el esperado debido a diversos factores, siendo quizás el más importante la lentitud y el reducido ancho de banda de las comunicaciones en aquel entonces que limitaba el tamaño de las applets que se incrustaban en el navegador. La aparición posterior de otras alternativas (aplicaciones web dinámicas de servidor) dejó un reducido ámbito de uso para esta tecnología, quedando hoy relegada fundamentalmente a componentes específicos para la intermediación desde una aplicación web dinámica de servidor con dispositivos ubicados en la máquina cliente donde se ejecuta el navegador.

Las applets Java no son las únicas tecnologías (aunque sí las primeras) de componentes complejos incrustados en el navegador. Otras tecnologías similares pueden ser: ActiveX de Microsoft, Flash, Java Web Start, etc.

En sistemas de servidor

En la parte del servidor, Java es más popular que nunca, desde la aparición de la especificación de Servlets y JSP (Java Server Pages).

Hasta entonces, las aplicaciones web dinámicas de servidor que existían se basaban fundamentalmente en componentes CGI y lenguajes interpretados. Ambos tenían diversos inconvenientes (fundamentalmente lentitud, elevada carga computacional o de memoria y propensión a errores por su interpretación dinámica).

Los servlets y las JSPs supusieron un importante avance ya que:
- El API de programación es muy sencilla, flexible y extensible.
- Los servlets no son procesos independientes (como los CGIs) y por tanto se ejecutan dentro del mismo proceso que la JVM mejorando notablemente el rendimiento y reduciendo la carga computacional y de memoria requeridas.
- Las JSPs son páginas que se compilan dinámicamente (o se pre-compilan previamente a su distribución) de modo que el código que se consigue una ventaja en rendimiento substancial frente a muchos lenguajes interpretados.

La especificación de Servlets y JSPs define un API de programación y los requisitos para un contenedor (servidor) dentro del cual se puedan desplegar estos componentes para formar aplicaciones web dinámicas completas. Hoy día existen multitud de contenedores (libres y comerciales) compatibles con estas especificaciones.

A partir de su expansión entre la comunidad de desarrolladores, estas tecnologías han dado paso a modelos de desarrollo mucho más elaborados con frameworks (pe Struts, Webwork) que se sobreponen sobre los servlets y las JSPs para conseguir un entorno de trabajo mucho más poderoso y segmentado en el que la especialización de roles sea posible (desarrolladores, diseñadores gráficos,...) y se facilite la reutilización y robustez de código. A pesar de todo ello, las tecnologías que subyacen (Servlets y JSPs) son substancialmente las mismas.

Este modelo de trabajo se ha convertido en uno de los estándar de-facto para el desarrollo de aplicaciones web dinámicas de servidor.

En aplicaciones de escritorio

Hoy en día existen multitud de aplicaciones gráficas de usuario basadas en Java. El entorno de ejecución Java (JRE) se ha convertido en un componente habitual en los PC de usuario de los sistemas operativos más usados en el mundo. Además, muchas aplicaciones Java lo incluyen dentro del propio paquete de la aplicación de modo que se ejecuten en cualquier PC.

En las primeras versiones de la plataforma Java existían importantes limitaciones en las APIs de desarrollo gráfico (AWT). Desde la aparición de la biblioteca Swing la situación mejoró substancialmente y posteriormente con la aparición de bibliotecas como SWT hacen que el desarrollo de aplicaciones de escritorio complejas y con gran dinamismo, usabilidad, etc. sea relativamente sencillo.

Plataformas soportadas

Una versión del entorno de ejecución Java JRE (Java Runtime Environment) está disponible en la mayoría de equipos de escritorio. Sin embargo, Microsoft no lo ha incluido por defecto en sus sistemas operativos. En el caso de Apple, éste incluye una versión propia del JRE en su sistema operativo, el Mac OS. También es un producto que por defecto aparece en la mayoría de las distribuciones de GNU/Linux. Debido a incompatibilidades entre distintas versiones del JRE, muchas aplicaciones prefieren instalar su propia copia del JRE antes que confiar su suerte a la aplicación instalada por defecto. Los desarrolladores de applets de Java o bien deben insistir a los usuarios en la actualización del JRE, o bien desarrollar bajo una versión antigua de Java y verificar el correcto funcionamiento en las versiones posteriores.

Programación

Expresiones

Las expresiones son un conjunto de elementos o tokens junto con literales que son evaluados para devolver un resultado. Los tokens son elemento más pequeño de un programa que es significativo, e interpretado o entendido por el compilador, en java los tokens se dividen en cinco categorías que son:

Identificadores: Son las representaciones que se les da a los nombres que se asignan a las variables, clases, paquetes, métodos y constantes en el código de java para que el compilador los identifique y el programador pueda entenderlos. En java los identificadores pueden diferenciar entre mayúsculas o minúsculas por ser case sensitive, por lo que la variable cuyo nombre sea “Mivariable”, no es igual a “mivariable”, ya que java identifica estas como variables diferentes por el case sensitive, también se puede utilizar números, o el signo “_” para asignar un identificador.

Palabras claves: Son los identificadores reservados por java para cumplir con un objetivo específico en el código y el compilador, se usan de forma limitada y en casos específicos. Las palabras claves que usa java son las siguientes:

abstract 	boolean 	break 	byte 	case
catch 	char 	class 	continue 	default
do 	double 	else 	extends 	false
final 	finally 	float 	for 	if
implements 	import 	instanceof 	int 	interface
long 	native 	new 	null 	package
private 	protected 	public 	return 	short
static 	super 	switch 	syncronized 	this
throw 	throws 	transient 	true 	try
void 	volatile 	while 	var 	rest
byvalue 	cast 	const 	future 	generic
goto 	inner 	operator 	outer 	

Las palabras que se encuentran en negrilla, son palabras claves para java aunque actualmente no se utilicen en la versión de java, pero se pretenden integrar en las siguientes versiones de java.

Literales y constantes: Los literales son sintaxis para asignar valores a una variable, es decir el valor que puede tomar una variable, también es un valor constante que puede ser de tipo numérico. Las constantes son variables que tienen un valor fijo y no puede ser modificado en el trascurso de la ejecución del código, estas se declaran por medio de los modificadores final y static.

final static double pi= 3.1415;

Operadores: Son los que nos indican una evaluación que se aplica a un objeto o un dato, sobre un identificador o constante. Un ejemplo de operadores puede ser la suma, resta o multiplicación.

Separadores: Se utilizan para indicarle al compilador de java donde se ubican los elementos del código, los separadores que admite java son: { },:;

También el compilador de java identifica y elimina los comentarios, retornos de carros espacios vacíos y de tabulación a la hora de compilar por lo que no son considerados parte de un tokens.

Las expresiones pueden ser una combinación en secuencia de variables, operadores y métodos. Las expresiones son utilizadas para realizar cálculos, para asignar valores a variables, o para controlar la ejecución del flujo del programa.

Operadores

Los operadores son aquellos que tras realizar una operación devuelven un resultado, estos se puede caracterizar por el número de operadores, el tipo de operandos, y el resultado que generan.

Número de operandos. Pueden ser de dos tipos unarios, y binarios. Los unarios son aquellos que solo necesitan de un operando para devolver un valor, mientras que los binarios necesitan de dos o más operandos.

Operadores unarios.

Operador 	Descripción
- 	Cambio de signo
 ! 	Operador NOT
~ 	Complemento a 1

Operadores binarios.

Operadores 	Descripción
+ - * / % 	Operadores aritméticos
== != < > <= >= 	Operadores relacionales
&& || ^ 	Operadores booleanos
^ << >> >>> 	Operadores a nivel de bit
+ 	Concatenación de cadenas

Operadores a nivel de bit

Los operadores a nivel de bit nos permiten realizar operaciones sobre números binarios.

~ Complemento a 1, este operador invierte los dígitos, cambiando los 0 por 1 y los 1 por 0, un ejemplo puede ser:

  11001011
~ 11001011 resultado 00110100

Como se puede ver se cambian los valores de 0 a 1 y de 1 a 0.

& AND a nivel de bit, este operador realiza una operación AND o suma entre dos números de bit, en donde si dos bit son igual a 1 el resultado será 1, de lo contrario será 0, un ejemplo puede ser:

 situacion
   01001101
 & 10011011 
______________ 
   00001001

| Or a nivel de bit, este operador realiza una operación OR en donde si alguno de los dos números es 1 el resultado será 1, un ejemplo puede ser:

   11001101
 | 01011101 
______________
   11011101

^ XOR a nivel de bit, este operador realiza la operación XOR en donde si los dos números son iguales el resultado será 0 de lo contrario será 1, un ejemplo puede ser:

 
   00101001
 ^ 01101101 
______________
   01000100

<< Desplazamiento a la izquierda, este operador desplaza n cantidad de espacios a la izquierda un bit, un ejemplo puede ser;

01101110
01101110 << 2 = 11011100

Como se puede ver al realizar el desplazamiento se realiza una inserción de un dígito 0 a la derecha

Precedencia de operadores

Los operadores son una parte principal en las expresiones, el tipo y forma de uso es fundamental a la hora de programas, pero para su uso se tiene que tener en cuenta una serie de normas, como lo son la precedencia de los operadores.

Los operadores son ejecutados según su precedencia, si cuentan con una precedencia mayor serán evaluados primero que los de precedencia menor, si por casualidad se llegase a presentar operadores con el mismo nivel de precedencia, estos se evaluaran de derecha a izquierda, si son operadores binarios (menos los operadores de asignación) se evaluaran de izquierda a derecha. A Java se le puede indicar qué operadores debe evaluar primero sin importar su precedencia por medio de paréntesis ( ), de esta forma el compilador de java interpreta que primero ejecutara las operaciones que se encuentran dentro de los paréntesis, y luego continuara con los demás operadores. La siguiente tabla indicara en nivel de precedencia de los operadores utilizados en java, teniendo en cuenta que el nivel de precedencia está indicado de arriba a abajo, siendo arriba el nivel más alto.

Precedencia de los operadores en java.

Tipo de operadores 	Operadores
Operadores posfijos 	[ ] . ( parámetros) expr++ expr--
Operadores unarios 	++expr –expr +expr -expr ~ !
Creación o conversión 	New (tipo) expr
Multiplicación 	* / %
Suma 	+ -
Desplazamiento 	<< >> >>>
Comparación 	< > <= >= instanceof
Igualdad 	== !=
AND a nivel bit 	&
OR a nivel bit 	|
XOR a nivel bit 	^
AND lógico 	&&
OR lógico 	||
Condicional 	? :
Asignación 	= += -= *= /= %= &= ^= |= <<= >>= >>>=

Un ejemplo de la precedencia de los operadores en java podría ser el siguiente, en donde tenemos un código que se encargará de realizar una serie de operaciones aritméticas.

int numero1 = 3;
int numero2 = 4;
int resultado;
resultado = numero1 + numero2 * 3;
System.out.println (resultado); //esto imprime el valor de 15

según la precedencia de los operadores la multiplicación * tiene mayor prioridad que la suma +, por lo que primero se ejecuta la multiplicación y luego se realiza la suma.

int numero1 = 3;
int numero2 = 4;
int resultado;
resultado = (numero1 + numero2) * 3;
System.out.println (resultado); //esto imprime el valor de 21

En este caso el resultado cambia ya que primero se evalúan los parámetros que están dentro del paréntesis y luego se evalúa el resto de parámetros. Una de las recomendaciones que da java para el desarrollo es el uso de los paréntesis en las operaciones con más de 3 operandos, así de esta forma el código se hace más legible y se evitan errores al momento de compilar.

Sentencias

Las sentencias son una representación de una secuencia de acciones que se realizan en java, la clave fundamental de las sentencias es su punto final que indica que ha finalizado la sentencia y puede continuar con la siguiente, el indicador utilizado es el signo de punto y coma (;). Contamos en java con sentencias que pueden ir desde sentencias de asignación, de bucles, condicionales, y de salto. Las sentencias se conforman comúnmente por una instancia, y un operador, un ejemplo es la sentencia de asignación que se conforma por una instancia de una variable, el signo de asignación y una expresión, un ejemplo es:

int variable = 12+2;

Las sentencias de asignación son aquellas en las que se asigna un valor a una variable o constante. Las sentencias condicionales son las que expresan una condición para definir el flujo de ejecución del programa, entre ellas tenemos if-else y switch. Las sentencias de bucles se encargar de realizar una acción cierta cantidad de tiempo dado, o hasta que se cumpla con una condición, entre ellas tenemos el while, do-while, y for. Las sentencias de salto llevan al compilador a un punto específico del programa o hacia la siguiente sentencia de ejecución, entre ellas tenemos break, continue, y return.

Conversión de tipos

En algunos casos suele ser necesario convertir un tipo de dato a otro, esto se le conoce como conversión de tipos, modelado, o tipado, así de esta forma poder realizar las operaciones necesarias sobre el valor que se desea convertir. Se debe tener en cuenta el tipo de dato que se va a convertir, ya que si se convierte un dato que tenga una cantidad menor de bit al anterior este tendrá perdida de información, un ejemplo de tipado puede ser un número long que se desea convertir a int, el compilador eliminara los primeros 32bit del long para ajustarlo al int ya que el int es de 32bit y el long de 64. Si la conversión se realiza a un tipo de datos de menos bit a un tipo de datos con mayor bit, la conversión se realiza automáticamente llamada conversión implícita, pero si se realiza de un tipo de datos con mayor bit a menor bit se tiene que realizar una conversión explicita, la cual se realiza con un casting, al usar este método se obliga a realizar la conversión por lo cual puede haber perdida de datos en la conversión. Para realizar una conversión explicita se tiene que poner el tipo de dato que se desea realizar la conversión entre paréntesis, luego el valor o la variable que se desea convertir. Un ejemplo de conversión de tipo explicito puede ser:

Int numero1 = 32;
byte numero2;
numero2 = (byte) numero1;

Un ejemplo de una conversión de tipo implícita puede ser:

int numero1 = 32;
long numero2;
numero2 = numero1;

Las siguiente tabla muestra la los tipos de datos que se pueden realizar una conversión implícita desde el dato origen, hasta el dato destino que es el dato en el que se va a convertir.

Tipo origen 	Tipo destino
byte 	double, float, long, int, char, short
short 	double, float, long, int
char 	double, float, long, int
int 	double, float, long
long 	double, float
float 	double

Los tipos de datos booleanos no pueden ser convertidos a otro tipo de datos, por ningún método mencionado anteriormente. Otro tipo de conversión que no se encuentre en esta tabla desde el origen al destino, tiene que realizarse por medio de una conversión explícita por casting. Cuando se desea realizar una conversión de un tipo string como origen a otro tipo, es necesario utilizar una función que se encarga de convertir el tipo de dato, la función necesaria se compone de la variable que va almacenar el resultado, y dependiendo de la variable se usa el parámetro que inicia con el tipo de dato a convertir, Integer, Byte, Short, o Long, seguida de punto “. “, el cual indica que se cargarán los atributos del parámetro, en donde cargaremos el parseInt si queremos convertir a interger o parseByte si queremos convertir a byte, o dependiendo del tipo de dato, seguido de paréntesis en donde se agregara el valor de string a convertir. Algunos ejemplos puede ser:

int numero1;
long numero2;
byte numero3;
String texto= “2013”;
numero1 = Integer.parseInt ( texto );
numero2 = Long.parseLong ( texto);
numero3 = Byte.parseByte ( texto );

esto suele ser usado para realizar una conversión de texto cuando se ingresan valores numéricos por una entrada a java, la cual los detecta como string, así de esta forma puede convertir el texto que se ingresa a un número para realizar operaciones, como una calculadora.

Industria relacionada

Sun Microsystem, como creador del lenguaje de programación Java y de la plataforma JDK, mantiene fuertes políticas para mantener una especificación del lenguaje6 así como de la máquina virtual7 a través del JCP. Es debido a este esfuerzo que se mantiene un estándar de facto.

Son innumerables las compañías que desarrollan aplicaciones para Java y/o están volcadas con esta tecnología:
- La industria de la telefonía móvil está fuertemente influenciada por la tecnología Java.
- Los entornos de desarrollo Netbeans y Eclipse ha tomado un lugar importante entre la comunidad de desarrolladores Java.
- La fundación Apache tiene también una presencia importante en el desarrollo de bibliotecas y componentes de servidor basados en Java.
- IBM, BEA, IONA, Oracle,... son empresas con grandes intereses y productos creados en y para Java.

Críticas

En 1995 alguien dijo que Java fue creado para abrir una nueva vía en la gestión de software complejo, y es por regla general aceptado que se ha comportado bien en ese aspecto. Sin embargo no puede decirse que Java no tenga grietas, ni que se adapta completamente a todos los estilos de programación, todos los entornos, o todas las necesidades.

General

- Java no ha aportado capacidades estándares para aritmética en punto flotante. El estándar IEEE 754 para “Estándar para Aritmética Binaria en Punto Flotante” apareció en 1985, y desde entonces es el estándar para la industria. Y aunque la aritmética flotante de Java (cosa que cambió desde el 13 de noviembre de 2006, cuando se abrió el código fuente y se adoptó la licencia GPL, aparte de la ya existente)[cita requerida] se basa en gran medida en la norma del IEEE, no soporta aún algunas características. Más información al respecto puede encontrarse en la sección final de enlaces externos.

El lenguaje

- En un sentido estricto, Java no es un lenguaje absolutamente orientado a objetos, a diferencia de, por ejemplo, Ruby o Smalltalk. Por motivos de eficiencia, Java ha relajado en cierta medida el paradigma de orientación a objetos, y así por ejemplo, no todos los valores son objetos.
- El código Java puede ser a veces redundante en comparación con otros lenguajes. Esto es en parte debido a las frecuentes declaraciones de tipos y conversiones de tipo manual (casting). También se debe a que no se dispone de operadores sobrecargados, y a una sintaxis relativamente simple. Sin embargo, J2SE 5.0 introduce elementos para tratar de reducir la redundancia, como una nueva construcción para los bucles ‘’’foreach’’’.
- A diferencia de C++, Java no dispone de operadores de sobrecarga definidos por el usuario. Los diseñadores de Java tomaron esta decisión puesto que consideraban que, bajo ciertas circunstancias, esta característica podía complicar la lectura y mantenimiento de los programas.

Apariencia

La apariencia externa (el ‘‘‘look and feel’’’) de las aplicaciones GUI (Graphical User Interface) escritas en Java usando la plataforma Swing difiere a menudo de la que muestran aplicaciones nativas. Aunque el programador puede usar el juego de herramientas AWT (Abstract Windowing Toolkit) que genera objetos gráficos de la plataforma nativa, el AWT no es capaz de funciones gráficas avanzadas sin sacrificar la portabilidad entre plataformas; ya que cada una tiene un conjunto de APIs distinto, especialmente para objetos gráficos de alto nivel. Las herramientas de Swing, escritas completamente en Java, evitan este problema construyendo los objetos gráficos a partir de los mecanismos de dibujo básicos que deben estar disponibles en todas las plataformas. El inconveniente es el trabajo extra requerido para conseguir la misma apariencia de la plataforma destino. Aunque esto es posible (usando GTK+ y el Look-and-Feel de Windows), la mayoría de los usuarios no saben cómo cambiar la apariencia que se proporciona por defecto por aquella que se adapta a la de la plataforma.

Rendimiento

El bytecode de Java puede ser interpretado en tiempo de ejecución por la máquina virtual, o bien compilado al cargarse el programa, o durante la propia ejecución, para generar código nativo que se ejecuta directamente sobre el hardware. Si es interpretado, será más lento que usando el código máquina intrínseco de la plataforma destino. Si es compilado, durante la carga inicial o la ejecución, la penalización está en el tiempo necesario para llevar a cabo la compilación.

Algunas características del propio lenguaje conllevan una penalización en tiempo, aunque no son únicas de Java. Algunas de ellas son el chequeo de los límites de arrays, chequeo en tiempo de ejecución de tipos, y la indirección de funciones virtuales.

El uso de un recolector de basura para eliminar de forma automática aquellos objetos no requeridos, añade una sobrecarga que puede afectar al rendimiento, o ser apenas apreciable, dependiendo de la tecnología del recolector y de la aplicación en concreto. Las JVM modernas usan recolectores de basura que gracias a rápidos algoritmos de manejo de memoria, consiguen que algunas aplicaciones puedan ejecutarse más eficientemente.

El rendimiento entre un compilador JIT y los compiladores nativos puede ser parecido, aunque la distinción no está clara en este punto. La compilación mediante el JIT puede consumir un tiempo apreciable, un inconveniente principalmente para aplicaciones de corta duración o con gran cantidad de código. Sin embargo, una vez compilado, el rendimiento del programa puede ser comparable al que consiguen compiladores nativos de la plataforma destino, inclusive en tareas numéricas. Aunque Java no permite la expansión manual de llamadas a métodos, muchos compiladores JIT realizan esta optimización durante la carga de la aplicación y pueden aprovechar información del entorno en tiempo de ejecución para llevar a cabo transformaciones eficientes durante la propia ejecución de la aplicación. Esta recompilación dinámica, como la que proporciona la máquina virtual HotSpot de Sun, puede llegar a mejorar el resultado de compiladores estáticos tradicionales, gracias a los datos que sólo están disponibles durante el tiempo de ejecución.

Java fue diseñado para ofrecer seguridad y portabilidad, y no ofrece acceso directo al hardware de la arquitectura ni al espacio de direcciones. Java no soporta expansión de código ensamblador, aunque las aplicaciones pueden acceder a características de bajo nivel usando bibliotecas nativas (JNI, Java Native Interfaces).

Recursos

JRE

El JRE (Java Runtime Environment, o Entorno en Tiempo de Ejecución de Java) es el software necesario para ejecutar cualquier aplicación desarrollada para la plataforma Java. El usuario final usa el JRE como parte de paquetes software o plugins (o conectores) en un navegador Web. Sun ofrece también el SDK de Java 2, o JDK (Java Development Kit) en cuyo seno reside el JRE, e incluye herramientas como el compilador de Java, Javadoc para generar documentación o el depurador. Puede también obtenerse como un paquete independiente, y puede considerarse como el entorno necesario para ejecutar una aplicación Java, mientras que un desarrollador debe además contar con otras facilidades que ofrece el JDK.

Componentes

- Bibliotecas de Java, que son el resultado de compilar el código fuente desarrollado por quien implementa la JRE, y que ofrecen apoyo para el desarrollo en Java. Algunos ejemplos de estas bibliotecas son:
	- Las bibliotecas centrales, que incluyen:
		- Una colección de bibliotecas para implementar estructuras de datos como listas, arrays, árboles y conjuntos.
		- Bibliotecas para análisis de XML.
		- Seguridad.
		- Bibliotecas de internacionalización y localización.
	- Bibliotecas de integración, que permiten la comunicación con sistemas externos. Estas bibliotecas incluyen:
		- La API para acceso a bases de datos JDBC (Java DataBase Conectivity).
		- La interfaz JNDI (Java Naming and Directory Interface) para servicios de directorio.
		- RMI (Remote Method Invocation) y CORBA para el desarrollo de aplicaciones distribuidas.
	- Bibliotecas para la interfaz de usuario, que incluyen:
		- El conjunto de herramientas nativas AWT (Abstract Window Toolkit), que ofrece componentes GUI (Graphical User Interface), mecanismos para usarlos y manejar sus eventos asociados.
		- Las Bibliotecas de Swing, construidas sobre AWT pero ofrecen implementaciones no nativas de los componentes de AWT.
		- APIs para la captura, procesamiento y reproducción de audio.
- Una implementación dependiente de la plataforma en que se ejecuta de la máquina virtual de Java (JVM), que es la encargada de la ejecución del código de las bibliotecas y las aplicaciones externas.
- Plugins o conectores que permiten ejecutar applets en los navegadores Web.
- Java Web Start, para la distribución de aplicaciones Java a través de Internet.
- Documentación y licencia.

APIs

Sun define tres plataformas en un intento por cubrir distintos entornos de aplicación. Así, ha distribuido muchas de sus APIs (Application Program Interface) de forma que pertenezcan a cada una de las plataformas:
- Java ME (Java Platform, Micro Edition) o J2ME — orientada a entornos de limitados recursos, como teléfonos móviles, PDAs (Personal Digital Assistant), etc.
- Java SE (Java Platform, Standard Edition) o J2SE — para entornos de gama media y estaciones de trabajo. Aquí se sitúa al usuario medio en un PC de escritorio.
- Java EE (Java Platform, Enterprise Edition) o J2EE — orientada a entornos distribuidos empresariales o de Internet.

Las clases en las APIs de Java se organizan en grupos disjuntos llamados paquetes. Cada paquete contiene un conjunto de interfaces, clases y excepciones relacionadas. La información sobre los paquetes que ofrece cada plataforma puede encontrarse en la documentación de ésta.

El conjunto de las APIs es controlado por Sun Microsystems junto con otras entidades o personas a través del programa JCP (Java Community Process). Las compañías o individuos participantes del JCP pueden influir de forma activa en el diseño y desarrollo de las APIs, algo que ha sido motivo de controversia.

Extensiones y arquitecturas relacionadas

Las extensiones8 de Java están en paquetes que cuelgan de la raíz javax: javax.*. No se incluyen en la JDK o el JRE. Algunas de las extensiones y arquitecturas ligadas estrechamente al lenguaje Java son:
- Java EE (Java Platform, Enterprise Edition; antes J2EE) —para aplicaciones distribuidas orientadas al entorno empresarial

Java en código abierto

Java se ha convertido en un lenguaje con una implantación masiva en todos los entornos (personales y empresariales). El control que mantiene Sun sobre éste ha generado reticencias en la comunidad de empresas con fuertes intereses en Java (IBM, Oracle) y obviamente en la comunidad de desarrolladores de software libre.

La evolución basada en un comité en el que participen todos los implicados no es suficiente y la comunidad demandaba desde hace tiempo la liberación de las APIs y bibliotecas básicas de la JDK.

En diciembre de 2006, Sun Microsystems comenzó el relanzamiento de su plataforma Java9 bajo la licencia GPL de GNU.

En abril de 2009 Oracle adquirió Sun Microsystems, lo que generó temor en la comunidad ante la posible mercantilización del lenguaje de programación orientado a objetos más popular actualmente. Por ahora Oracle ha seguido manteniendo Java, estando las versiones posteriores a la 6 bajo su control.

Se instala una versión homebrew de PSPKVM (0.5.5) para emular la plataforma de Java en PSP. Esto permite usar programas JAVA en esta videoconsola.

Alternativas libres

Existen alternativas para el entorno de ejecución y de desarrollo de Java con una gran cobertura de funcionalidades con respecto a las implementaciones comerciales de Sun, IBM, Bea, etc.

Críticas referentes a Java y el software libre
- Free But Shackled — The Java Trap, de Richard Stallman, 12 de abril de 2004. (respuesta de James Gosling)
		- Traducción al español de este artículo: Libre pero encadenado. La trampa del Java. (Nótese que hay una nota en un recuadro amarillo que habla de la situación actual con respecto a lo que se dice en ese artículo)

Notar que este artículo fue escrito antes de la liberación del código fuente de Java. En la actualidad la postura de la Free Software Foundation y de Richard Stallman han cambiado[cita requerida], mostrándose partidarios ambos de su uso en software libre.

Referencias
- Jon Byous, Java technology: The early years. Sun Developer Network, sin fecha[ca. 1998]. Recuperado 21 de abril de 2005.
- James Gosling, A brief history of the Green project. Java.net, sin fecha [ca. Q1/1998]. Recuperado 22 abril de 2005.
- James Gosling, Bill Joy, Guy Steele, y Gilad Bracha, The Java language specification, tercera edición. Addison-Wesley, 2005. ISBN 0-321-24678-0.
- Tim Lindholm y Frank Yellin. The Java Virtual Machine specification, segunda edición. Addison-Wesley, 1999. ISBN 0-201-43294-3.

Notas
1. Overview - D Programming Language
2. «Programming Language Popularity» (2009). Consultado el 16-01-2009.
3. «TIOBE Programming Community Index» (2009). Consultado el 06-05-2009.
4. «Jonathan Schwartz's Blog: Different Isn't Always Better, But Better's Always Different». Blogs.sun.com. Consultado el 24 de septiembre de 2010.
5. M. Domínguez-Dorado,. Todo Programación. Nº 8. Págs. 39-42. Editorial Iberprensa (Madrid). DL M-13679-2004. Febrero, 2005.. Dibujando sobre lienzos en Java..
6. Especificación del lenguaje Java
7. Especificación de la máquina virtual Java
8. M. Domínguez-Dorado, Guillermo Som. Todo Programación. Nº 11. Págs. 10-20. Editorial Iberprensa (Madrid). DL M-13679-2004. Agosto, 2005.. Imprimir desde Java y .NET..
9. Sun begins releasing Java under the GPL - Free Software Foundation
